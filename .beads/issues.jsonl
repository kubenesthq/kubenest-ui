{"id":"kubenest-ui-044","title":"Static template catalog for demo (Railway-style one-click deploys)","description":"## Context\n\nFor the demo, we want to show Railway-style one-click template deployments without needing a backend template storage system. A static catalog hardcoded in the frontend is sufficient.\n\n## What to build\n\nA new page: /projects/[id]/templates (or as a tab on the project page)\n\n### Template card grid\n\nDisplay 6-8 templates as cards:\n- Icon + name + short description\n- \"Deploy\" button ‚Üí navigates to pre-filled workload/addon creation flow\n\n### Static template definitions (lib/constants/templates.ts)\n\n```ts\nexport interface TemplateComponent {\n  kind: 'workload' | 'addon';\n  name: string;          // placeholder name, user can override\n  type?: string;         // addon type: postgres | redis | etc.\n  chart?: ChartSpec;     // for addon components\n  image?: string;        // for workload components\n  port?: number;\n}\n\nexport interface Template {\n  id: string;\n  name: string;\n  description: string;\n  icon: string;          // emoji or icon name\n  tags: string[];        // e.g. ['database', 'backend', 'popular']\n  components: TemplateComponent[];\n}\n\nexport const TEMPLATES: Template[] = [\n  {\n    id: 'postgres',\n    name: 'PostgreSQL',\n    description: 'Managed PostgreSQL database',\n    icon: 'üêò',\n    tags: ['database'],\n    components: [{\n      kind: 'addon', name: 'postgres', type: 'postgres',\n      chart: { repo: 'https://charts.bitnami.com/bitnami', name: 'postgresql', version: '12.1.2' }\n    }]\n  },\n  {\n    id: 'redis',\n    name: 'Redis',\n    description: 'In-memory cache and message broker',\n    icon: '‚ö°',\n    tags: ['cache', 'database'],\n    components: [{ kind: 'addon', name: 'redis', type: 'redis',\n      chart: { repo: 'https://charts.bitnami.com/bitnami', name: 'redis', version: '18.0.0' } }]\n  },\n  {\n    id: 'nginx',\n    name: 'NGINX',\n    description: 'Web server and reverse proxy',\n    icon: 'üåê',\n    tags: ['web'],\n    components: [{ kind: 'workload', name: 'nginx', image: 'nginx:latest', port: 80 }]\n  },\n  // ... more templates\n];\n```\n\n### Deploy flow\n\nClicking \"Deploy\" on a template with a single component:\n- Workload template ‚Üí navigate to /projects/[id]/workloads/new pre-filled with chart/image\n- Addon template ‚Üí navigate to /projects/[id]/addons/new pre-filled with chart/type\n\nClicking \"Deploy\" on a multi-component template:\n- For demo: show a simple dialog with a name input, then sequentially create each component\n- Later: proper stack deploy API call (once backend epic kubenest-backend-8nf is done)\n\n## Scope for demo\n\nThe demo needs at minimum: PostgreSQL, Redis, and one workload template (nginx or node.js).\nThe multi-component stack flow can be simplified to just showing what would be created.\n\n## Notes\n\n- Addon creation page (addons/new) does not yet exist ‚Äî this task depends on the addon API\n  being available (kubenest-backend-b9i). Build the catalog page first with mock/disabled\n  deploy buttons, enable them once addons API is ready.\n- No backend changes needed for this bead. It is purely frontend static data + UI.","status":"open","priority":2,"issue_type":"task","owner":"badri.dilbert@gmail.com","created_at":"2026-02-19T13:57:17.522709+05:30","created_by":"Lakshmi Narasimhan","updated_at":"2026-02-19T13:57:17.522709+05:30"}
{"id":"kubenest-ui-0e6","title":"Complete workload deployment flow","description":"Deploy workloads, view workload details with real-time SSE status updates","status":"open","priority":1,"issue_type":"epic","created_at":"2025-11-26T11:45:50.946002+05:30","updated_at":"2025-11-26T11:45:50.946002+05:30"}
{"id":"kubenest-ui-2wp","title":"Add Helm chart deploy mode to workload creation form","description":"## Context\n\nThe backend now supports deploying workloads via custom Helm charts instead of the default kubenest-workload chart. The API accepts two new optional fields on POST /workloads:\n- `chart`: `{ repo: string, name: string, version: string }`\n- `values`: arbitrary JSON object of Helm values\n\nThe workload response object now includes `chart_config: { chart?: ChartSpec, values?: Record\u003cstring, unknown\u003e } | null`.\n\n## Goal\n\nExtend the \"Deploy New Workload\" form and workload detail page to support Helm chart deployments alongside the existing image-based flow.\n\n---\n\n## Files to change\n\n### 1. `types/api.ts`\n\nAdd `ChartSpec` interface and extend existing types:\n\n\\`\\`\\`ts\nexport interface ChartSpec {\n  repo: string;   // Helm repo URL, e.g. https://charts.bitnami.com/bitnami\n  name: string;   // Chart name, e.g. postgresql\n  version: string; // Semver chart version, e.g. 12.1.2\n}\n\\`\\`\\`\n\nAdd to `Workload` interface:\n\\`\\`\\`ts\nchart_config: { chart?: ChartSpec; values?: Record\u003cstring, unknown\u003e } | null;\n\\`\\`\\`\n\nAdd to `CreateWorkloadRequest`:\n\\`\\`\\`ts\nchart?: ChartSpec;\nvalues?: Record\u003cstring, unknown\u003e;\n\\`\\`\\`\n\n---\n\n### 2. `app/projects/[id]/workloads/new/page.tsx`\n\n#### Deploy mode toggle\n\nAdd a mode selector at the top of the form with two options: **Image** (default) and **Helm Chart**. Use `useState\u003c'image' | 'chart'\u003e('image')`.\n\n#### Updated Zod schema\n\nRemove the hard `z.string().min(1)` requirement on `image`. Add chart fields. Use `.superRefine()` to cross-validate:\n- In `image` mode: `image` is required\n- In `chart` mode: `chart.repo`, `chart.name`, `chart.version` are all required; `image` is ignored\n\n\\`\\`\\`ts\nconst chartSpecSchema = z.object({\n  repo: z.string().url('Must be a valid URL'),\n  name: z.string().min(1, 'Chart name is required'),\n  version: z.string().min(1, 'Version is required'),\n});\n\nconst workloadSchema = z.object({\n  name: z.string().min(1).regex(/^[a-z0-9-]+$/),\n  image: z.string().optional(),\n  replicas: z.number().int().min(0).max(100),\n  port: z.number().int().min(1).max(65535).optional().nullable(),\n  ingress: ingressSchema.optional(),\n  chart: chartSpecSchema.optional(),\n  valuesYaml: z.string().optional(), // raw YAML/JSON text input, parsed before submit\n});\n\\`\\`\\`\n\n#### Conditional field rendering\n\nWhen mode is `'image'`: show `Container Image` field (required), hide chart fields.\nWhen mode is `'chart'`: hide image field, show three chart fields (Repo, Name, Version) + optional Helm Values textarea.\n\n#### Helm Values textarea\n\n- Collapsible section (same pattern as Ingress)\n- Accepts YAML or JSON (use `js-yaml` if already in deps, else JSON only is fine)\n- Parse to object before submitting; show parse error inline if invalid\n\n#### `onSubmit` handler changes\n\n\\`\\`\\`ts\n// image mode (current behavior unchanged)\nif (mode === 'image') {\n  payload.image = data.image;\n}\n\n// chart mode\nif (mode === 'chart') {\n  payload.chart = data.chart;\n  if (data.valuesYaml) {\n    try {\n      payload.values = JSON.parse(data.valuesYaml); // or yaml.load()\n    } catch {\n      setError('valuesYaml', { message: 'Invalid JSON/YAML' });\n      return;\n    }\n  }\n}\n\\`\\`\\`\n\n---\n\n### 3. `app/workloads/[id]/page.tsx`\n\nIn the **Workload Details** card, update the source row:\n\n- If `workload.chart_config?.chart` exists: show chart badge with repo/name@version instead of the Image row\n- If `workload.image` exists: show the existing Image row (no change)\n- Both can coexist (image + values override case), but chart takes priority as the label\n\nReplace the hardcoded `Image` entry in the details array with:\n\n\\`\\`\\`tsx\nworkload.chart_config?.chart\n  ? {\n      label: 'Helm Chart',\n      value: (\n        \u003ccode className=\"text-xs bg-zinc-100 text-zinc-700 px-2 py-1 rounded font-mono block truncate\"\u003e\n          {workload.chart_config.chart.name}@{workload.chart_config.chart.version}\n          \u003cspan className=\"text-zinc-400 ml-1\"\u003e({workload.chart_config.chart.repo})\u003c/span\u003e\n        \u003c/code\u003e\n      ),\n    }\n  : {\n      label: 'Image',\n      value: (\n        \u003ccode className=\"text-xs bg-zinc-100 text-zinc-700 px-2 py-1 rounded font-mono block truncate\"\u003e\n          {workload.image}\n        \u003c/code\u003e\n      ),\n    },\n\\`\\`\\`\n\nIf `chart_config.values` is non-empty, add a collapsible **Helm Values** section below the details card showing the values as formatted JSON.\n\n---\n\n## Acceptance criteria\n\n- [ ] Deploy form shows Image/Helm Chart toggle\n- [ ] Image mode: existing behaviour unchanged, all existing tests pass\n- [ ] Chart mode: chart repo/name/version fields shown and validated\n- [ ] Chart mode: Helm Values textarea accepts JSON and shows parse errors\n- [ ] Submitting in chart mode sends `{ chart: {...}, values: {...} }` in the API payload (no `image`)\n- [ ] Workload detail page shows \"Helm Chart\" source row instead of \"Image\" when `chart_config` is set\n- [ ] TypeScript types are updated ‚Äî no `any` casts needed\n\n## Notes\n\n- `WorkloadPhase` in `types/api.ts` currently has lowercase values (`running`, `failed`, etc.) but the backend returns Title-case (`Running`, `Failed`). Check if this mismatch causes any issues while you are in this file.\n- No new dependencies are strictly required; use JSON.parse for values unless js-yaml is already installed.\n- The `lib/api/workloads.ts` and `hooks/useWorkloads.ts` files do NOT need changes ‚Äî they pass the payload through as-is.","status":"closed","priority":2,"issue_type":"feature","owner":"badri.dilbert@gmail.com","created_at":"2026-02-19T13:40:58.325157+05:30","created_by":"Lakshmi Narasimhan","updated_at":"2026-02-19T13:47:01.113547+05:30","closed_at":"2026-02-19T13:47:01.113547+05:30","close_reason":"Implemented: Image/Helm Chart toggle on workload form, ChartSpec types, chart_config on workload detail page with collapsible Helm Values section. All typechecks pass."}
{"id":"kubenest-ui-7js","title":"Workload metrics: real-time CPU/memory/request charts in workload detail","description":"## Context\n\nWhen kube-prometheus-stack is installed as a cluster addon (optional), Prometheus scrapes workload metrics and Grafana provides dashboards. The workload detail page should surface basic metrics inline without requiring users to open Grafana directly.\n\n## What to display\n\nBasic real-time metrics for the workload (last 30 minutes, auto-refresh every 15s):\n- CPU usage (millicores)\n- Memory usage (MiB)\n- HTTP request rate (req/s) ‚Äî only if the workload exposes metrics endpoint\n- Error rate ‚Äî optional\n\nThese are fetched directly from the Prometheus API (not Grafana embed) so we control the rendering.\n\n## How it works\n\nCluster model (backend) will have a prometheus_url field when monitoring is installed.\nThe backend exposes a proxy/passthrough endpoint:\n  GET /workloads/:id/metrics?query=\u003cpromql\u003e\u0026start=\u0026end=\u0026step=\n\n(Proxying avoids CORS issues and keeps Prometheus internal to the cluster.)\n\nAlternatively, if Grafana is exposed, embed a pre-built dashboard panel via iframe.\n\n## UI changes (app/workloads/[id]/page.tsx)\n\nAdd a **Metrics** card below the Scale Controls card. Shown only when:\n- `workload.phase === 'Running'` (or 'Degraded')\n- `cluster.prometheus_url` is set (need to fetch cluster via project)\n\nInside the card:\n- Three small sparkline charts (Recharts or similar, already check if in deps)\n- Time range selector: 15m | 1h | 6h\n- Auto-refresh toggle (on by default, 15s interval using useInterval)\n- Loading skeleton while fetching\n\n## API client changes (lib/api/)\n\nNew file: `lib/api/metrics.ts`\n```ts\nexport const metricsApi = {\n  query: (workloadId: string, params: MetricsQueryParams) =\u003e\n    apiClient.get\u003cMetricsResponse\u003e(`/workloads/${workloadId}/metrics`, { params }),\n};\n```\n\n## Hook (hooks/useWorkloadMetrics.ts)\n\n```ts\nexport function useWorkloadMetrics(workloadId: string, range: '15m' | '1h' | '6h') {\n  return useQuery({\n    queryKey: ['metrics', workloadId, range],\n    queryFn: () =\u003e metricsApi.query(workloadId, { range }),\n    refetchInterval: 15_000,\n    enabled: !!workloadId,\n  });\n}\n```\n\n## Backend prerequisite\n\nA GET /workloads/:id/metrics endpoint that queries Prometheus and returns:\n```json\n{\n  \"cpu\": [{ \"t\": 1234567890, \"v\": 125.4 }, ...],\n  \"memory\": [{ \"t\": 1234567890, \"v\": 256.0 }, ...],\n  \"rps\": [{ \"t\": 1234567890, \"v\": 12.3 }, ...]\n}\n```\nThis backend endpoint is a separate bead. The frontend can stub it initially with mock data.\n\n## Notes\n\n- Check if Recharts or similar is already in package.json before adding a dependency.\n- Metrics card should gracefully degrade: if cluster has no prometheus_url, show a subtle\n  \"Install the monitoring addon to view metrics\" message instead of the charts.\n- Do NOT embed Grafana iframes ‚Äî too heavy, auth is complex, poor UX.\n- The monitoring addon (kube-prometheus-stack) is optional at the cluster level.\n  Backend bead: \"Add prometheus_url to Cluster and expose /workloads/:id/metrics proxy\"","status":"open","priority":2,"issue_type":"feature","owner":"badri.dilbert@gmail.com","created_at":"2026-02-19T13:57:00.292264+05:30","created_by":"Lakshmi Narasimhan","updated_at":"2026-02-19T13:57:00.292264+05:30"}
{"id":"kubenest-ui-9ch","title":"Add real-time SSE status updates","description":"Implement SSE provider and hooks for live workload status updates","status":"open","priority":1,"issue_type":"feature","created_at":"2025-11-26T11:45:59.097971+05:30","updated_at":"2025-11-26T11:45:59.097971+05:30","dependencies":[{"issue_id":"kubenest-ui-9ch","depends_on_id":"kubenest-ui-0e6","type":"parent-child","created_at":"2025-11-26T11:46:16.677719+05:30","created_by":"daemon","metadata":"{}"}]}
{"id":"kubenest-ui-bbx","title":"Complete cluster management flow","description":"Register clusters, view cluster details, copy install command","status":"open","priority":1,"issue_type":"epic","created_at":"2025-11-26T11:45:50.368118+05:30","updated_at":"2025-11-26T11:45:50.368118+05:30"}
{"id":"kubenest-ui-ddu","title":"Fix Toaster component import error","description":"Toaster component was missing - needed use-toast.ts and toaster.tsx","status":"closed","priority":0,"issue_type":"bug","created_at":"2025-11-26T11:46:04.084068+05:30","updated_at":"2025-11-26T11:46:09.009991+05:30","closed_at":"2025-11-26T11:46:09.009991+05:30"}
{"id":"kubenest-ui-jdi","title":"Complete MVP authentication flow","description":"Ensure login/register/logout works end-to-end with proper state management","notes":"COMPLETED: Fixed auth API endpoints to match backend (login uses form-urlencoded, register uses /user endpoint). Login and register pages now functional with proper API calls.\nIN PROGRESS: Need to verify login/register flow works end-to-end.\nNEXT: Test with real user credentials.","status":"in_progress","priority":1,"issue_type":"epic","created_at":"2025-11-26T11:45:50.120014+05:30","updated_at":"2025-11-26T12:00:15.255209+05:30"}
{"id":"kubenest-ui-qxy","title":"Polish and error handling","description":"Loading states, error pages, form validation, responsive design","status":"open","priority":2,"issue_type":"epic","created_at":"2025-11-26T11:45:59.435732+05:30","updated_at":"2025-11-26T11:45:59.435732+05:30"}
{"id":"kubenest-ui-wqw","title":"Complete project management flow","description":"Create projects within clusters, view project details and workloads","status":"open","priority":1,"issue_type":"epic","created_at":"2025-11-26T11:45:50.593302+05:30","updated_at":"2025-11-26T11:45:50.593302+05:30"}
